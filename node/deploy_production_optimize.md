# Express在生产环境下的最佳实践 - 性能和可靠性

## 需要对代码做的事

- 使用gzip压缩
- 禁止使用同步方法
- 使用中间件来提供静态文件
- 适当地打印日志
- 合理地处理异常

### 使用gzip压缩
```js
var compression = require('compression');
app.use(compression());
```
对于在生产环境中，流量十分大的网站，最好是在反向代理层处理压缩。如果这样做，那么就不就需要使用compression了，而是需要参阅Nginx的 *ngx_http_gzip_module* 模块的文档。

### 禁止使用同步方法

同步方法会在它返回之前都一直阻塞线程。一次单独的调用可能影响不大，但在流量非常巨大的生产环境中，它是不可接受的，可能会导致严重的性能问题。

虽然大多数的Node.js和其第三方库都同时提供了一个方法的同步和异步版本，但在生产环境下，请总是使用它的异步版本。唯一可能例外的场景可能是，如果这个方法只在应用初始化时调用一次，那么使用它的同步版本也是可以接受的。

如果你使用的是Node.js 4.0+ 或 io.js 2.1.0+ ，你可以在启动应用时附上 *--trace-sync-io* 参数来检查你的应用中哪里使用了同步API。更多关于这个参数的信息，你可以参阅io.js 2.1.0的更新日志。

### 使用中间件来提供静态文件

在开发环境下，你可以使用 *res.sendFile()* 来提供静态文件。但在生产环境下，这是不被允许的，因为这个方法会在每次请求时都会对文件系统进行读取。res.sendFile()并不是通过系统方法sendfile实现的。

对应的，你可以使用 *serve-static* 中间件来为你的Express应用提供静态文件。

更好的选择则是在反向代理层上提供静态文件。

### 适当地打印日志

总得来说，为你的应用打印日志的目的有两个：调试和操作记录。在开发环境下，我们通常使用 *console.log()* 或 *console.err()* 来做这些事。但是，当这些方法的输出目标是终端或文件时，它们是同步的，所以它们并不适用于生产环境，除非你将输出导流至另一个程序中。

##### 为了调试

如果你正在为了调试而打印日志。那么你可以使用一些专用于调试的库如 *debug*，用于代替 *console.log()* 。这个库可以通过设置 *DEBUG* 环境变量来控制具体哪些信息会被打印。虽然这些方法也是同步的，但你一定不会在生产环境下进行调试吧？

##### 为了操作记录

如果你正在为了记录应用的活动而打印日志。那么你可以使用一些日志库如 *winston* 或 *Bunyan*，来替代console.log()。更多关于这两个库的详情，可以参阅这里。

###

Node.js在遇到未处理的异常时就会退出。如果没有合理地捕获并处理异常，这会使你的应用崩溃和离线。如果你使用了一个自动重启的工具，那么你的应用则会在崩溃后立刻重启，而且幸运的是，Express应用的重启时间通常都很快。但是不管怎样，你都想要尽量避免这种崩溃。

为了保证你合理处理异常，请遵从以下指示：

- 使用try-catch
- 使用promise

后面还有好多要学的

[链接](http://www.phperz.com/article/15/1129/170602.html)
